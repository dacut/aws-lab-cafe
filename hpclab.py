#!/usr/bin/env python2.7
from __future__ import absolute_import, print_function
from base64 import b64encode
from botocore.exceptions import ClientError
from boto3.session import Session as Boto3Session
from cracklib import VeryFascistCheck
from cStringIO import StringIO
from flask import (
    escape, flash, Flask, g, make_response, redirect, render_template, request,
    session, url_for,
)
from functools import wraps
from httplib import BAD_REQUEST, FORBIDDEN, UNAUTHORIZED
from os import environ, urandom
from passlib.hash import pbkdf2_sha512
from six import text_type
from time import time
from validate_email import validate_email

# Customize the Boto3Session arguments according to your needs.
b3_session = Boto3Session(region_name="us-west-2")

# DynamoDB table name prefix
dynamodb_table_prefix = "HPCLab."

# Handles to various AWS services; you shouldn't need to customize anything
# below this line.
dynamodb = b3_session.resource("dynamodb")
ddb_events = dynamodb.Table(dynamodb_table_prefix + "Events")
ddb_unallocinst = dynamodb.Table(dynamodb_table_prefix + "UnallocatedInstances")
ddb_users = dynamodb.Table(dynamodb_table_prefix + "Users")
ec2 = b3_session.client("ec2")
kms = b3_session.client("kms")

# This is a hash for a password that can't be deduced. It was generated by:
# pbkdf2_sha512.encrypt(urandom(128), rounds=96000)
invalid_password_hash = (
    "$pbkdf2-sha512"
    "$96000"
    "$8Z6TkrI2ZsyZUwoBYOy99w"
    "$8OJdNMyRfmUcLFTvK5bxxAy4Bal.X1r1J75VsW/DD4"
    "OmSXpbvYOERa4RBWSR0D2lch7sEU2wFtKfEl5IlUaQSQ")

app = Flask(__name__)
if "HPCLAB_CONFIG" in environ:
    app.config.from_envvar("HPCLAB_CONFIG")

app.jinja_env.globals["static_prefix"] = "static/"
app.jinja_env.globals["prefix"] = "/"

# Enable SSL if configured
if app.config.get("SSL_CERT_CHAIN_FILE") and app.config.get("SSL_KEY_FILE"):
    from ssl import SSLContext, PROTOCOL_TLSv1_2
    ssl_context = SSLContext(PROTOCOL_TLSv1_2)
    ssl_context.load_cert_chain(
        app.config["SSL_CERT_CHAIN_FILE"], app.config["SSL_KEY_FILE"])
else:
    ssl_context = None

# Configure the session secrets from KMS
session_key_ciphertext = app.config["KMS_ENCRYPTED_SESSION_KEY"]
app.config["SECRET_KEY"] = kms.decrypt(
    CiphertextBlob=session_key_ciphertext)["Plaintext"]

def is_valid_event_id(event_id):
    """
    Indicates whether this is a valid event id.
    """
    response = ddb_events.get_item(
        Key={"EventId": event_id},
        ProjectionExpression="EventName",
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    return item is not None

def get_user(email, event_id):
    """
    If this is a valid user email and event id pair (and the event id is still
    valid), return details about the user. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression="FullName,InstanceId",
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    if item is not None and is_valid_event_id(event_id):
        return item

    return None

def login_user(email, password, event_id):
    """
    If this user is known and passes authentication checks, returns details
    about the user and sets session details. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression="FullName,InstanceId,PasswordHash",
        ReturnConsumedCapacity="TOTAL",
    )

    # We ALWAYS perform a password verification to prevent timing-based attacks.
    # If we skip this when a user is not found, an attacker can deduce whether
    # an email has been registered by monitoring the time it takes for
    # verification.
    item = response.get("Item")
    if item is None:
        password_hash = invalid_password_hash
    else:
        password_hash = item.pop("PasswordHash", "")

    if not pbkdf2_sha512.verify(password, password_hash):
        return None

    session["Email"] = email
    session["EventId"] = event_id

    return item

def register_user(email, password, event_id, full_name, allow_contact):
    """
    If the user does not already exist for this event, register him/her.
    """
    pwhash = pbkdf2_sha512.encrypt(password)
    item = {
        "Email": email,
        "EventId": event_id,
        "PasswordHash": pwhash,
        "FullName": full_name,
        "AllowContact": allow_contact,
        "CreationDate": int(time()),
    }

    try:
        ddb_users.put_item(
            Item=item,
            ConditionExpression="attribute_not_exists(EventId)",
            ReturnConsumedCapacity="TOTAL",
        )
    except ClientError as e:
        error_code = getattr(e, "response", {}).get("Error", {}).get("Code", "")
        if error_code == u"ConditionalCheckFailedException":
            # User already exists.
            return None
        raise

    session["Email"] = email
    session["EventId"] = event_id
    del item["PasswordHash"]
    return item

# CSRF protection
@app.before_request
def csrf_protect():
    if request.method == "POST":
        cookie_token = session.get("_csrf_token")
        form_token = request.form.get("_csrf_token")
        if not cookie_token or cookie_token != form_token:
            print("CSRF token mismatch:\n    Cookie: %s\n    Form: %s" %
                (cookie_token, form_token))
            return make_response(render_template("error.html"), FORBIDDEN)
    return

def generate_csrf_token():
    if "_csrf_token" not in session:
        session["_csrf_token"] = b64encode(urandom(36))
    return session["_csrf_token"]
app.jinja_env.globals["csrf_token"] = generate_csrf_token

def require_valid_session(f):
    @wraps(f)
    def wrapper(*args, **kw):
        email = session.get("Email", None)
        event_id = session.get("EventId", None)

        if email is None or event_id is None:
            return redirect("/login")

        request.user = get_user(email, event_id)
        if request.user is None:
            del session["Email"]
            del session["EventId"]
            return redirect("/login")

        return f(*args, **kw)

    return wrapper

@app.route("/", methods=["GET"])
@require_valid_session
def index(**kw):
    return render_template("index.html", user=request.user)

@app.route("/login", methods=["GET"])
def login(**kw):
    return render_template("login.html", form={})

@app.route("/login", methods=["POST"])
def login_post(**kw):
    action = request.form.get("Action")
    event_id = request.form.get("EventId")
    email = request.form.get("Email")
    full_name = request.form.get("FullName")
    password = request.form.get("Password")
    action = request.form.get("Action")
    password_verify = request.form.get("PasswordVerify")
    allow_contact = request.form.get("AllowContact")

    def redo(status_code):
        return make_response(
            render_template("login.html", form=request.form), status_code)

    if action == "Login":
        if event_id is None or email is None or password is None:
            flash("<b>Missing form fields</b>", category="error")
            return redo(BAD_REQUEST)

        if not is_valid_event_id(event_id):
            flash("<b>Unknown event code %s</b>" % escape(event_id),
                category="error")
            return redo(UNAUTHORIZED)

        user = login_user(email, password, event_id)
        if not user:
            flash("<b>Invalid username or password</b>", category="error")
            return redo(UNAUTHORIZED)

        next = request.args.get("next")
        return redirect(next or url_for("/"))
    elif action == "Register":
        if (event_id is None or email is None or password is None or
            password_verify is None or full_name is None):
            flash("<b>Missing form fields</b>")
            return redo(BAD_REQUEST)

        if not event_id:
            flash("<b>Missing event code</b>", category="error")
            return redo(BAD_REQUEST)

        if not is_valid_event_id(event_id):
            flash("<b>Unknown event code %s</b>" % escape(event_id),
                category="error")
            return redo(UNAUTHORIZED)

        if not validate_email(email):
            flash("<b>Invalid email address</b>", category="error")
            return redo(BAD_REQUEST)

        password_errors = []
        if len(password) < 12:
            password_errors.append("Password is too short.")

        upper_seen = lower_seen = digit_seen = symbol_seen = False
        for c in password:
            upper_seen |= c.isupper()
            lower_seen |= c.islower()
            digit_seen |= c.isdigit()
            symbol_seen |= not(c.isupper() and c.islower() and c.isdigit())

        if not upper_seen:
            password_errors.append("Password does not contain an uppercase letter.")
        if not lower_seen:
            password_errors.append("Password does not contain a lowercase letter.")
        if not digit_seen:
            password_errors.append("Password does not contain a digit.")
        if not symbol_seen:
            password_errors.append("Password does not contain a symbol.")
        try:
            if not password_errors:
                VeryFascistCheck(password)
        except ValueError:
            password_errors.append(
                "Password is easily guessed "
                "(was guessed by <a href=\"https://www.cyberciti.biz/security/linux-password-strength-checker/\">Cracklib</a>).")

        if password != password_verify:
            password_errors.append("Passwords do not match.")

        if password_errors:
            flash("<b>Invalid password:</b><br>" + "<br>".join(password_errors),
                  category="error")
            return redo(BAD_REQUEST)

        user = register_user(email, password, event_id, full_name, allow_contact)
        if user is None:
            flash("<b>User is already registered. "
                  "<a href='/forgot-password'>Click here</a> to reset your "
                  "password.</b>", category="error")
            return redo(BAD_REQUEST)

        return redirect("/")
    else:
        flash("<b>Invalid form data sent</b>", category="error")
        return redo(BAD_REQUEST)

@app.route("/logout", methods=["GET", "POST"])
def logout(**kw):
    if "Email" in session:
        del session["Email"]
        session.modified = True

    if "EventId" in session:
        del session["EventId"]
        session.modified = True

    if session.modified:
        flash("You have been logged out.", category="info")
    return redirect("/login")

if __name__ == "__main__":
    app.run(ssl_context=ssl_context)
