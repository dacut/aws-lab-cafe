#!/usr/bin/env python2.7
from __future__ import absolute_import, print_function
from base64 import b64encode
from botocore.exceptions import ClientError
from boto3.session import Session as Boto3Session
from cracklib import VeryFascistCheck
from cStringIO import StringIO
from flask import (
    escape, flash, Flask, g, make_response, redirect, render_template, request,
    session, url_for,
)
from functools import wraps
from httplib import BAD_REQUEST, FORBIDDEN, OK, UNAUTHORIZED
from os import environ, urandom
from passlib.hash import pbkdf2_sha512
from six import text_type
from subprocess import Popen, PIPE
from tempfile import mkstemp
from time import time
from validate_email import validate_email

# Customize the Boto3Session arguments according to your needs.
b3_session = Boto3Session(region_name="us-west-2")

# DynamoDB table name prefix
dynamodb_table_prefix = "HPCLab."

# You shouldn't need to customize anything below this line.

# Handles to various AWS services.
dynamodb = b3_session.resource("dynamodb")
ddb_events = dynamodb.Table(dynamodb_table_prefix + "Events")
ddb_unallocinst = dynamodb.Table(dynamodb_table_prefix + "UnallocatedInstances")
ddb_users = dynamodb.Table(dynamodb_table_prefix + "Users")
ec2 = b3_session.client("ec2")
kms = b3_session.client("kms")

# This is a hash for a password that can't be deduced. It was generated by:
# pbkdf2_sha512.encrypt(urandom(128), rounds=96000)
invalid_password_hash = (
    "$pbkdf2-sha512"
    "$96000"
    "$8Z6TkrI2ZsyZUwoBYOy99w"
    "$8OJdNMyRfmUcLFTvK5bxxAy4Bal.X1r1J75VsW/DD4"
    "OmSXpbvYOERa4RBWSR0D2lch7sEU2wFtKfEl5IlUaQSQ")

# The attributes on a user to return from DynamoDB (excludes HashedPassword)
user_attributes = ",".join(
    ["Email", "EventId", "InstanceId", "FullName", "AllowContact",
     "CreationDate", "SSHPrivateKey", "SSHPublicKey", "UserId"]
)

app = Flask(__name__)
if "HPCLAB_CONFIG" in environ:
    print("Reading configuration from %s" % environ["HPCLAB_CONFIG"])
    app.config.from_envvar("HPCLAB_CONFIG")

app.jinja_env.globals["static_prefix"] = "static/"
app.jinja_env.globals["prefix"] = "/"

# Enable SSL if configured
if app.config.get("SSL_CERT_CHAIN_FILE") and app.config.get("SSL_KEY_FILE"):
    from ssl import SSLContext, PROTOCOL_TLSv1_2
    ssl_context = SSLContext(PROTOCOL_TLSv1_2)
    ssl_context.load_cert_chain(
        app.config["SSL_CERT_CHAIN_FILE"], app.config["SSL_KEY_FILE"])
else:
    ssl_context = None

# Configure the session secrets from KMS
session_key_ciphertext = app.config["KMS_ENCRYPTED_SESSION_KEY"]
app.config["SECRET_KEY"] = kms.decrypt(
    CiphertextBlob=session_key_ciphertext)["Plaintext"]

def is_valid_event_id(event_id):
    """
    Indicates whether this is a valid event id.
    """
    response = ddb_events.get_item(
        Key={"EventId": event_id},
        ProjectionExpression="EventName",
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    return item is not None
app.jinja_env.globals["is_valid_event_id"] = is_valid_event_id

def get_instance_info(instance_id):
    """
    Return the public IP address for a given instance id.
    """
    response = ec2.describe_instances(InstanceIds=[instance_id])
    return response["Reservations"][0]["Instances"][0]
app.jinja_env.globals["get_instance_info"] = get_instance_info

def get_user(email, event_id):
    """
    If this is a valid user email and event id pair (and the event id is still
    valid), return details about the user. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression=user_attributes,
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    if item is not None and is_valid_event_id(event_id):
        return item

    return None

def login_user(email, password, event_id):
    """
    If this user is known and passes authentication checks, returns details
    about the user and sets session details. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression=(user_attributes + ",PasswordHash"),
        ReturnConsumedCapacity="TOTAL",
    )

    # We ALWAYS perform a password verification to prevent timing-based attacks.
    # If we skip this when a user is not found, an attacker can deduce whether
    # an email has been registered by monitoring the time it takes for
    # verification.
    item = response.get("Item")
    if item is None:
        password_hash = invalid_password_hash
    else:
        password_hash = item.pop("PasswordHash", "")

    if not pbkdf2_sha512.verify(password, password_hash):
        return None

    session["Email"] = email
    session["EventId"] = event_id

    return item

def generate_private_public_key(bits=2048):
    """
    generate_private_public_key(bits=2048) -> dict
    Generate an OpenSSH private/public keypair.

    The resulting dict has the form:
        { "PrivateKey": private_key, "PublicKey": public_key }
    """
    if bits not in (1024, 2048, 4096):
        raise ValueError("bits must be 1024, 2048, or 4096")

    proc = Popen(["/usr/bin/openssl", "genrsa", str(bits)], stdin=PIPE,
                 stdout=PIPE, stderr=PIPE)
    private_key, err = proc.communicate()
    if proc.returncode != 0:
        raise RuntimeError("Failed to generate private key: %s" % err.strip())

    proc = Popen(["/usr/bin/openssl", "rsa", "-inform", "PEM", "-pubout"],
                 stdin=PIPE, stdout=PIPE, stderr=PIPE)
    public_key, err = proc.communicate(private_key)
    if proc.returncode != 0:
        raise RuntimeError("Failed to generate public key: %s" % err.strip())

    return {"PrivateKey": private_key, "PublicKey": public_key}

def register_user(email, password, event_id, full_name, allow_contact):
    """
    If the user does not already exist for this event, register him/her.
    """
    pwhash = pbkdf2_sha512.encrypt(password)
    keys = generate_private_public_key()

    user_item = {
        "Email": email,
        "EventId": event_id,
        "PasswordHash": pwhash,
        "FullName": full_name,
        "AllowContact": allow_contact,
        "CreationDate": int(time()),
        "SSHPrivateKey": keys["PrivateKey"],
        "SSHPublicKey": keys["PublicKey"],
    }

    # Get the next user id.
    while True:
        event_item = ddb_events.get_item(
            Key={"EventId": event_id},
            ProjectionExpression="NextUID",
            ReturnConsumedCapacity="TOTAL",
        )["Item"]

        user_id = event_item["NextUID"]

        try:
            ddb_events.update_item(
                Key={"EventId": event_id},
                UpdateExpression="SET NextUID = NextUID + :incr",
                ConditionExpression="NextUID = :current_uid",
                ExpressionAttributeValues={
                    ":current_uid": user_id,
                    ":incr": 1,
                },
                ReturnConsumedCapacity="TOTAL",
            )
            break
        except ClientError as e:
            error_code = (
                getattr(e, "response", {}).get("Error", {}).get("Code", ""))
            if error_code != u"ConditionalCheckFailedException":
                raise

            # Concurrent modification; try again.

    try:
        ddb_users.put_item(
            Item=user_item,
            ConditionExpression="attribute_not_exists(EventId)",
            ReturnConsumedCapacity="TOTAL",
        )
    except ClientError as e:
        error_code = getattr(e, "response", {}).get("Error", {}).get("Code", "")
        if error_code == u"ConditionalCheckFailedException":
            # User already exists.
            return None
        raise

    session["Email"] = email
    session["EventId"] = event_id
    del user_item["PasswordHash"]
    return user_item

# CSRF protection
@app.before_request
def csrf_protect():
    if request.method == "POST":
        cookie_token = session.get("_csrf_token")
        form_token = request.form.get("_csrf_token")
        if not cookie_token or cookie_token != form_token:
            print("CSRF token mismatch:\n    Cookie: %s\n    Form: %s" %
                (cookie_token, form_token))
            return make_response(render_template("error.html"), FORBIDDEN)
    return

def generate_csrf_token():
    if "_csrf_token" not in session:
        session["_csrf_token"] = b64encode(urandom(36))
    return session["_csrf_token"]
app.jinja_env.globals["csrf_token"] = generate_csrf_token

def require_valid_session(f):
    @wraps(f)
    def wrapper(*args, **kw):
        email = session.get("Email", None)
        event_id = session.get("EventId", None)

        if email is None or event_id is None:
            return redirect("/login")

        request.user = get_user(email, event_id)
        if request.user is None:
            del session["Email"]
            del session["EventId"]
            return redirect("/login")

        return f(*args, **kw)

    return wrapper

@app.route("/", methods=["GET"])
@require_valid_session
def index(**kw):
    return render_template("index.html", user=request.user)

@app.route("/ssh-key", methods=["GET"])
@require_valid_session
def get_ssh_key(**kw):
    format = request.args.get("format", "PEM")
    priv_key = request.user["SSHPrivateKey"]
    event_id = request.user["EventId"]

    headers = {
        "Cache-Control": "private"
    }

    if format == "PEM":
        result = priv_key
        headers["Content-Type"] = "application/x-pem-file"
        headers["Content-Disposition"] = (
            'attachment; filename="%s-private.pem"' % (event_id,))
    elif format == "PPK":
        # Convert this to a PuTTY PPK file using puttygen. Note that puttygen
        # reopens the incoming PEM file, so /dev/stdin can't be used here.
        puttygen = app.config.get("PUTTYGEN", "/usr/bin/puttygen")
        temp_pem, temp_pem_filename = mkstemp(
            suffix=".pem", prefix="privkey", text=True)
        temp_pem.write(priv_key)
        temp_pem.flush()
        temp_pem.seek(0)

        proc = Popen([puttygen, temp_pem, "-o", "/dev/stdout"], stdin=PIPE,
                     stdout=PIPE, stderr=PIPE)
        ppk, err = proc.communicate()
        if proc.returncode != 0:
            raise ValueError("puttygen failed to convert PEM file: %s" %
                             err.strip())

        temp_pem.close()
        del temp_pem

        result = ppk
        headers["Content-Type"] = "application/octet-stream"
        headers["Content-Disposition"] = 'attachment; filename="%s.ppk"' % (
            event_id,)

    return make_response((result, OK, headers))

@app.route("/login", methods=["GET"])
def login(**kw):
    return render_template("login.html", form={})

@app.route("/login", methods=["POST"])
def login_post(**kw):
    action = request.form.get("Action")
    event_id = request.form.get("EventId")
    email = request.form.get("Email")
    full_name = request.form.get("FullName")
    password = request.form.get("Password")
    action = request.form.get("Action")
    password_verify = request.form.get("PasswordVerify")
    allow_contact = request.form.get("AllowContact")

    def redo(status_code):
        return make_response(
            render_template("login.html", form=request.form), status_code)

    if action == "Login":
        if event_id is None or email is None or password is None:
            flash("<b>Missing form fields</b>", category="error")
            return redo(BAD_REQUEST)

        if not is_valid_event_id(event_id):
            flash("<b>Unknown event code %s</b>" % escape(event_id),
                category="error")
            return redo(UNAUTHORIZED)

        user = login_user(email, password, event_id)
        if not user:
            flash("<b>Invalid username or password</b>", category="error")
            return redo(UNAUTHORIZED)

        next = request.args.get("next")
        return redirect(next or url_for("/"))
    elif action == "Register":
        if (event_id is None or email is None or password is None or
            password_verify is None or full_name is None):
            flash("<b>Missing form fields</b>")
            return redo(BAD_REQUEST)

        if not event_id:
            flash("<b>Missing event code</b>", category="error")
            return redo(BAD_REQUEST)

        if not is_valid_event_id(event_id):
            flash("<b>Unknown event code %s</b>" % escape(event_id),
                category="error")
            return redo(UNAUTHORIZED)

        if not validate_email(email):
            flash("<b>Invalid email address</b>", category="error")
            return redo(BAD_REQUEST)

        password_errors = []
        if len(password) < 12:
            password_errors.append("Password is too short.")

        upper_seen = lower_seen = digit_seen = symbol_seen = False
        for c in password:
            upper_seen |= c.isupper()
            lower_seen |= c.islower()
            digit_seen |= c.isdigit()
            symbol_seen |= not(c.isupper() and c.islower() and c.isdigit())

        if not upper_seen:
            password_errors.append("Password does not contain an uppercase letter.")
        if not lower_seen:
            password_errors.append("Password does not contain a lowercase letter.")
        if not digit_seen:
            password_errors.append("Password does not contain a digit.")
        if not symbol_seen:
            password_errors.append("Password does not contain a symbol.")
        try:
            if not password_errors:
                VeryFascistCheck(password)
        except ValueError:
            password_errors.append(
                "Password is easily guessed "
                "(was guessed by <a href=\"https://www.cyberciti.biz/security/linux-password-strength-checker/\">Cracklib</a>).")

        if password != password_verify:
            password_errors.append("Passwords do not match.")

        if password_errors:
            flash("<b>Invalid password:</b><br>" + "<br>".join(password_errors),
                  category="error")
            return redo(BAD_REQUEST)

        user = register_user(email, password, event_id, full_name, allow_contact)
        if user is None:
            flash("<b>User is already registered. "
                  "<a href='/forgot-password'>Click here</a> to reset your "
                  "password.</b>", category="error")
            return redo(BAD_REQUEST)

        return redirect("/")
    else:
        flash("<b>Invalid form data sent</b>", category="error")
        return redo(BAD_REQUEST)

@app.route("/logout", methods=["GET", "POST"])
def logout(**kw):
    if "Email" in session:
        del session["Email"]
        session.modified = True

    if "EventId" in session:
        del session["EventId"]
        session.modified = True

    if session.modified:
        flash("You have been logged out.", category="info")
    return redirect("/login")

if __name__ == "__main__":
    app.run(ssl_context=ssl_context)
