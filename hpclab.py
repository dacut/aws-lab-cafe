#!/usr/bin/env python2.7
from __future__ import absolute_import, print_function
from cStringIO import StringIO
from base64 import b64encode
from boto3.session import Session as Boto3Session
from flask import (
    flash, Flask, g, make_response, redirect, render_template, request, session,
    url_for,
)
from functools import wraps
from httplib import FORBIDDEN, UNAUTHORIZED
from os import environ, urandom
from passlib.hash import pbkdf2_sha512
from six import text_type

# Customize the Boto3Session arguments according to your needs.
b3_session = Boto3Session(region_name="us-west-2")

# DynamoDB table name prefix
dynamodb_table_prefix = "HPCLab."

# Handles to various AWS services; you shouldn't need to customize anything
# below this line.
dynamodb = b3_session.resource("dynamodb")
ddb_events = dynamodb.Table(dynamodb_table_prefix + "Events")
ddb_unallocinst = dynamodb.Table(dynamodb_table_prefix + "UnallocatedInstances")
ddb_users = dynamodb.Table(dynamodb_table_prefix + "Users")
ec2 = b3_session.client("ec2")
kms = b3_session.client("kms")

# This is a hash for a password that can't be deduced. It was generated by:
# pbkdf2_sha512.encrypt(urandom(128), rounds=96000)
invalid_password_hash = (
    "$pbkdf2-sha512"
    "$96000"
    "$8Z6TkrI2ZsyZUwoBYOy99w"
    "$8OJdNMyRfmUcLFTvK5bxxAy4Bal.X1r1J75VsW/DD4"
    "OmSXpbvYOERa4RBWSR0D2lch7sEU2wFtKfEl5IlUaQSQ")

app = Flask(__name__)
if "HPCLAB_CONFIG" in environ:
    app.config.from_envvar("HPCLAB_CONFIG")

app.jinja_env.globals["static_prefix"] = "static/"
app.jinja_env.globals["prefix"] = "/"

# Enable SSL if configured
if app.config.get("SSL_CERT_CHAIN_FILE") and app.config.get("SSL_KEY_FILE"):
    from ssl import SSLContext, PROTOCOL_TLSv1_2
    ssl_context = SSLContext(PROTOCOL_TLSv1_2)
    ssl_context.load_cert_chain(
        app.config["SSL_CERT_CHAIN_FILE"], app.config["SSL_KEY_FILE"])
else:
    ssl_context = None

# Configure the session secrets from KMS
session_key_ciphertext = app.config["KMS_ENCRYPTED_SESSION_KEY"]
app.config["SECRET_KEY"] = kms.decrypt(
    CiphertextBlob=session_key_ciphertext)["Plaintext"]

def is_valid_event_id(event_id):
    """
    Indicates whether this is a valid event id.
    """
    response = ddb_events.get_item(
        Key={"EventId": event_id},
        ProjectionExpression="EventName",
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    return item is not None

def get_user(email, event_id):
    """
    If this is a valid user email and event id pair (and the event id is still
    valid), return details about the user. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression="FullName,InstanceId",
        ReturnConsumedCapacity="TOTAL",
    )

    item = response.get("Item")
    if item is not None and is_valid_event_id(event_id):
        return item

    return None

def login_user(email, password, event_id):
    """
    If this user is known and passes authentication checks, returns details
    about the user and sets session details. Otherwise, returns None.
    """
    response = ddb_users.get_item(
        Key={"Email": email, "EventId": event_id},
        ProjectionExpression="FullName,InstanceId,PasswordHash",
        ReturnConsumedCapacity="TOTAL",
    )

    # We ALWAYS perform a password verification to prevent timing-based attacks.
    # If we skip this when a user is not found, an attacker can deduce whether
    # an email has been registered by monitoring the time it takes for
    # verification.
    item = response.get("Item")
    if item is None:
        password_hash = invalid_password_hash
    else:
        password_hash = item.pop("PasswordHash", "")

    if not pbkdf2_sha512.verify(password, password_hash):
        return None

    session["Email"] = email
    session["EventId"] = event_id

    return item

# CSRF protection
@app.before_request
def csrf_protect():
    if request.method == "POST":
        cookie_token = session.get("_csrf_token")
        form_token = request.form.get("_csrf_token")
        if not cookie_token or cookie_token != form_token:
            print("CSRF token mismatch:\n    Cookie: %s\n    Form: %s" %
                (cookie_token, form_token))
            return make_response(render_template("error.html"), FORBIDDEN)
    return

def generate_csrf_token():
    if "_csrf_token" not in session:
        session["_csrf_token"] = b64encode(urandom(36))
    return session["_csrf_token"]
app.jinja_env.globals["csrf_token"] = generate_csrf_token

def require_valid_session(f):
    @wraps(f)
    def wrapper(*args, **kw):
        email = session.get("Email", None)
        event_id = session.get("EventId", None)

        if email is None or event_id is None:
            return redirect("/login")

        request.user = get_user(email, event_id)
        if request.user is None:
            del session["Email"]
            del session["EventId"]
            raise redirect("/login")

        return f(*args, **kw)

    return wrapper

@app.route("/", methods=["GET"])
@require_valid_session
def index(**kw):
    return render_template("index.html", user=request.user)

@app.route("/login", methods=["GET"])
def login(**kw):
    return render_template("login.html")

@app.route("/login", methods=["POST"])
def login_post(**kw):
    event_id = request.form.get("EventId")
    email = request.form.get("Email")
    password = request.form.get("Password")

    if event_id is None or email is None or password is None:
        return redirect("/login")

    if not is_valid_event_id(event_id):
        flash("Unknown event code %s" % event_id, category="error")
        return make_response(render_template("login.html"), UNAUTHORIZED)

    user = login_user(email, password, event_id)
    if not user:
        flash("<b>Invalid username or password</b>", category="error")
        return make_response(render_template("login.html"), UNAUTHORIZED)

    next = request.args.get("next")
    return redirect(next or url_for("/"))

@app.route("/logout", methods=["GET", "POST"])
def logout(**kw):
    if "Email" in session:
        del session["Email"]
        session.modified = True

    if "EventId" in session:
        del session["EventId"]
        session.modified = True

    if session.modified:
        flash("You have been logged out.", category="info")
    return redirect("/login")

if __name__ == "__main__":
    app.run(ssl_context=ssl_context)
